<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wirepas Single-MCU SDK: Single-MCU API Operation Principle</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Wirepas Single-MCU SDK"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../small_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wirepas Single-MCU SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,true,'search.html','Search');
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d7/d28/application_operation.html','../../');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Single-MCU API Operation Principle </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="operation_principle"></a>
Single-MCU API Operation Principle</h1>
<p>The Wirepas Mesh stack and the application can communicate via a Single-MCU API. The application is designed to have a <a class="el" href="../../de/d7a/how_to_develop.html#app_init">single-entry point</a>. This entry point is called by the Wirepas Mesh stack at boot. The application must do its initialization during the application entry point call.</p>
<p>Also, during the application <a class="el" href="../../de/d7a/how_to_develop.html#app_init">entry point call</a>, the Wirepas Mesh stack provides a list of services to the application. These services are implemented as a list of C callback functions. Most importantly, these services includes opening libraries (used by <a class="el" href="../../dc/d65/api_8h.html#abea8e1483d9fe0c251a2027a34422031">API_Open()</a> function).</p>
<h1><a class="anchor" id="build"></a>
Build process</h1>
<p>The build can be divided in three steps:</p>
<ol type="1">
<li>Build the application and generate a binary and an OTAP image for the application</li>
<li>The binary is combined with the Wirepas Mesh stack binary provided by Wirepas to generate an OTAP image is generated to update both stack and app at the same time.</li>
<li>The OTAP image is combined with the Wirepas Mesh bootloader binary provided by Wirepas to generate an image that can be flashed directly to a blank device.</li>
</ol>
<div class="image">
<img src="../../image8.png" alt="image8.png"/>
</div>
<h1><a class="anchor" id="memory_partitioning"></a>
Memory Partitioning</h1>
<p>The application entry point and different callback functions are visualized in following picture:</p>
<div class="image">
<img src="../../image3.png" alt="image3.png"/>
</div>
<p>The flash memory partitioning includes the following regions:</p>
<ul>
<li><b>Bootloader</b>: Used by Wirepas Mesh OTAP functionality to take new firmware (application or/and Wirepas Mesh stack) into use.</li>
<li><b>Wirepas Mesh stack</b>: Wirepas Mesh stack firmware.</li>
<li><b>Customer</b> <b>application</b>: Customer application firmware.</li>
<li><b>Scratchpad</b>: Used by the Wirepas Mesh OTAP functionality to store new firmware (application or/and Wirepas Mesh stack) before taking it into use.</li>
<li><b>Reserved area</b>: Reserved for future use</li>
<li><b>Persistent area</b>: Used for storing persistent variables of the Wirepas Mesh stack.</li>
</ul>
<p>Dedicated areas in flash and in RAM are reserved for the application. Size for these areas are platform dependent and described in <a class="el" href="../../dd/d6a/sdk_environment.html">SDK</a>Environment". The C stack is shared between the application and the Wirepas Mesh stack. The application entry point must be allocated at the start of the application dedicated flash area. This is mandatory for the Wirepas Mesh stack to be able to know the application entry point location at run time.</p>
<div class="image">
<img src="../../image4.png" alt="image4.png"/>
</div>
<h1><a class="anchor" id="application_detection"></a>
Application Detection</h1>
<p>Device requires application to be working properly. Without application, the stack itself is not started and radio communication is thus disabled. Wirepas Mesh stack checks the presence of the application at run time. The detection depends of the value of the first two bytes of the application dedicated flash area. If it is equal to <code>0xFFFF</code> (default value), the Wirepas Mesh stack detects that there is no application and execution ends there. Otherwise, Wirepas Mesh stack calls the application <a class="el" href="../../de/d7a/how_to_develop.html#app_init">entry point</a> at this address. It is up to the customer to have positioned the function entry point here with the correct prototype. All the code needed to correctly position the right function at the right position is provided in the SDK.</p>
<h1><a class="anchor" id="cooperative_mcu_access"></a>
Cooperative MCU Access</h1>
<p>Wirepas Mesh stack is a real-time system and is based on a cooperative scheduler. Tasks are scheduled based on their priorities and their execution times. To operate correctly, all the deadlines must be respected and each task must complete within the duration reported to the scheduler.</p>
<p>If a task asks the scheduler to execute for a given period, it must finish its work in the corresponding allocated window. Being late can <em>affect the whole system performance and may result in incorrect operation </em>. The scheduler cannot pre-empt a task. Thus, special care must be taken to guarantee that a task finishes on time.</p>
<p>An application task can get run-time in basically three different ways:</p>
<ol type="1">
<li>via <a class="el" href="../../d7/d28/application_operation.html#periodic_application">periodic application callback function</a></li>
<li>via <a class="el" href="../../d7/d28/application_operation.html#asynchronous_application_callback_functions">asynchronous</a> application callback functions"</li>
<li>via interrupt. There are two types of interrupts: <a class="el" href="../../d7/d28/application_operation.html#fast_interrupt">fast</a> and <a class="el" href="../../d7/d28/application_operation.html#deferred_interrupt">deferred interrupts</a>.</li>
</ol>
<h2><a class="anchor" id="periodic_application"></a>
Periodic Application Callback Function</h2>
<p>Callback Function</p>
<p>The application can register one of its callback functions to be called at a given time and for a given period. At the end of its execution, the callback function returns the delay to be scheduled again. This mode allows the application to do periodical jobs, such as reading and sending a sensor value.</p>
<p>It must be noted, that the periodic application callback function is not necessarily called exactly at the requested time. The application task has lower priority than the Wirepas Mesh stack tasks. Thus, the application execution can be delayed to execute Wirepas Mesh stack tasks.</p>
<p>The application latency (delay between the requested start time and the real start time) depends on the execution duration specified during the callback function registration. The shorter the duration, the easier it is for the scheduler to find a time slot for the task. It is important to correctly size this time. It must be big enough to ensure that the callback function meets its deadline but small enough to reduce the latency.</p>
<p>Figure below illustrates an example of scheduling the application task. Application registers its periodic task (callback) at time t<sub>0</sub>. Time t<sub>1</sub> is the requested execution time of the application task. At time t<sub>2</sub> there is a first free timeslot to run the task, but it cannot be run because the requested duration (T<sub>req</sub>) is longer than the free time (T<sub>free</sub> = t<sub>3</sub>-t<sub>2</sub>). At time t<sub>4</sub> there is enough time to run the application and the task is scheduled. The requested time includes a lot of margin (T<sub>exec</sub> &lt; T<sub>req</sub>) and the application task finishes before its deadline. With a more accurate sizing (T<sub>exec</sub> vs. T<sub>req</sub>) the application task could have also been scheduled earlier at time t<sub>2</sub>.</p>
<p>Check out service for <a class="el" href="../../dc/db2/system_8h.html#a3bbe9181ed7a154eb9d2baf96f337701">lib_system-&gt;setPeriodicCb()</a> and <a class="el" href="../../dd/ddc/app__scheduler_8h.html">app scheduler library</a> or more information on how this is done with API services.</p>
<div class="image">
<img src="../../image5.png" alt="image5.png"/>
</div>
<h2><a class="anchor" id="asynchronous_application_callback_functions"></a>
Asynchronous Application Callback Functions</h2>
<p>Application Callback Functions</p>
<p>The application can also be executed asynchronously if the Wirepas Mesh stack has something to communicate to it, e.g. a message received from the network. This is done via callback functions the application provides to Wirepas Mesh stack at initialization.</p>
<p>These callback functions are called during a Wirepas Mesh stack task execution. Thus, the execution delay for these callback functions must be kept as short as possible. The application must avoid doing long processing or long operation (accessing a device for example). The recommended implementation is to save a state to be processed later. A good practice is to handle the data processing in the next periodically scheduled work (periodic application callback function). The schedule of the periodic work can also be updated to an earlier time if needed, but only one periodic work can be registered at a time. If no work is scheduled yet, it can be registered during the callback function. For recommended maximum periods, check <a class="el" href="../../d7/d28/application_operation.html#execution_time_limits">guidance on</a>maximum execution time limits".</p>
<p>An example of processing an asynchronous callback function is presented in Figure below. At t<sub>1</sub>, the Wirepas Mesh stack calls one of the asynchronous application callback functions. The application handles it in a very short period and schedules a work to do the processing at t<sub>3</sub>.</p>
<p>There are plenty of various asynchronous callbacks served by the system. Depending on the callback, there may be tighter time limits, especially if the callback is called from the IRQ context. Most common callback used and example of such callback is <a class="el" href="../../d2/dbd/data_8h.html#a13489e95ff4f3593662f9d65b5239a85">unicast data reception callback</a>.</p>
<div class="image">
<img src="../../image6.png" alt="image6.png"/>
</div>
<h2><a class="anchor" id="application_interrupt"></a>
Application Interrupt</h2>
<p>The application can register to hardware interrupts. It must provide its own interrupt handler table (same format as the platform one) to Wirepas Mesh stack.</p>
<p>Application interrupts can then be enabled/disabled with a specific API services <code><a class="el" href="../../dc/db2/system_8h.html#a350a09c1934fdd3217523f328e2ed833">lib_system-&gt;enableAppIrq</a></code> service and <code><a class="el" href="../../dc/db2/system_8h.html#ae871f054c8d6cf9441d1c2a362efdd1d">lib_system-&gt;disableAppIrq</a> </code> service.</p>
<p>There are two kinds of interrupts. Deferred interrupt and fast interrupt.</p>
<h3><a class="anchor" id="deferred_interrupt"></a>
Deferred interrupt</h3>
<p>The interrupts are handled in two levels: Wirepas Mesh stack implements the first-level interrupt handler which handles minimal needed operations (fast) in the interrupt context, and the application implements the second-level interrupt handler which is scheduled when there is enough free time.</p>
<p>Like in the periodic work, the application has a maximum duration time for its interrupt handler. As the latency to handle the interrupt at application-level is directly linked to the execution time of the application interrupt handler, the maximum execution time is set to 100us, see also <a class="el" href="../../d7/d28/application_operation.html#execution_time_limits">guidance on maximum</a>execution time limits".</p>
<p>Below, there are 4 different scenarios for interrupts described:</p>
<p>In scenario 1, an interrupt fires whilst the Wirepas Mesh stack executes one of its tasks. The first Wirepas Mesh stack first level interrupt handler is call immediately and the interrupt line is disabled. The app second-level interrupt handler is scheduled to be executed as soon as possible. In this scenario, the Wirepas Mesh stack has enough free time before its next task, it can schedule the application interrupt handler. The interrupt line is enabled again.</p>
<p>In scenario 2, the application interrupt handler cannot be scheduled between the two Wirepas Mesh stack task because there is not enough time.</p>
<p>In scenario 3, the interrupt fires during an idle state. The interrupt wakes up the platform and is handled by the Wirepas Mesh stack and the application without any additional scheduling latency.</p>
<p>In scenario 4, the interrupt fires during the execution of an application periodic work. The first level interrupt handling happens during the application periodic task but the application handler is only executed at the end of the task. The application cannot be pre-empted by its own application interrupt handlers. This simplifies the design of the application regarding data protection.</p>
<div class="image">
<img src="../../image7.png" alt="image7.png"/>
</div>
<h3><a class="anchor" id="fast_interrupt"></a>
Fast interrupt</h3>
<p>The interrupts are handled directly by the application. So it can preempt the stack execution. For this reason, the handling must be short (few micro seconds) to avoid breaking the stack internal scheduling. See also <a class="el" href="../../d7/d28/application_operation.html#execution_time_limits">guidance on maximum execution time limits</a>.</p>
<p>Fast interrupts can also preempt application task, so concurrent data access can happen and protection mechanism must be implemented. Services in the API are available for that purpose: <code><a class="el" href="../../dc/db2/system_8h.html#a5ba9aa0bc74144cd4ba0590021549eae">lib_system-&gt;enterCriticalSection()</a></code> and <code> <a class="el" href="../../dc/db2/system_8h.html#ae9a6c2ed09285b9175e2d1f7ae73b0f2">lib_system-&gt;exitCriticalSection()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>Due to concurrency issues and execution time limits, most services should <b>not</b> be used from fast interrupt execution context. Recommendation is to call <a class="el" href="../../d7/d28/application_operation.html#periodic_application">Periodic Application Callback Function</a> periodic application callback (using <a class="el" href="../../dc/db2/system_8h.html#a3bbe9181ed7a154eb9d2baf96f337701">lib_system-&gt;setPeriodicCb()</a> service or <a class="el" href="../../dd/ddc/app__scheduler_8h.html">app scheduler</a> library) and call services from there. Services that are known safe to be used from fast interrupt context are explicitly described in service documentation.</dd></dl>
<h2><a class="anchor" id="which_kind_of_interrupt_for_which_purpose"></a>
Which kind of interrupt for which purpose</h2>
<p>for which purpose</p>
<p>Fast interrupt must be used only when latency to serve the interrupt is crucial. For example, in case of a UART driver with a small FIFO hardware depth, fast interrupt must be used to avoid losing bytes. In this situation, the UART IRQ handler will just flush the byte from the hardware FIFO and store it in a software one to keep the handler execution short. No data processing must be done in the handler. Handling must be deferred to a periodic work.</p>
<p>But in many other situations, deferred interrupts can be used instead as it is easier to implement. In fact, as the handler is executed in a deferred task, execution time is less critical (it is currently limited to 100 micro seconds). As handler is executed as a task, it cannot preempt the app periodic task so no data protection mechanism is needed.</p>
<h2><a class="anchor" id="execution_time_limits"></a>
Execution time limits</h2>
<p>In the following table, the various types of methods on how application requests run-time and their maximum execution time are summarized:</p>
<table class="doxtable">
<tr>
<th>Execution type</th><th>Maximum execution time </th></tr>
<tr>
<td>Periodic application callback function </td><td>Application may request execution time and is safe to spend execution up to that time (max time is set to 100 ms) </td></tr>
<tr>
<td>Asynchronous callback functions </td><td>Generally 1 ms, (callback from thread context). Some callbacks (mentioned explicitly) are called from IRQ context and have maximum execution time of 50 us. </td></tr>
<tr>
<td>Deferred interrupt</td><td>1 ms </td></tr>
<tr>
<td>Fast interrupt</td><td>50 us </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Mar 12 2020 12:10:29 for Wirepas Single-MCU SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
